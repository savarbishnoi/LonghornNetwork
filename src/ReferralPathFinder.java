package src;

import java.util.*;

/**
 * Performs a referral path search using Dijkstra's algorithm on a {@link StudentGraph}.
 *
 * <p>The goal is to find the most reliable sequence of student connections that leads
 * from a starting student to any student who has previously interned at the
 * target company.</p>
 *
 * <h3>Cost Model</h3>
 * Each graph edge has a <strong>connection strength</strong> (0–10).  
 * To convert this into a graph traversal cost:
 *
 * <pre>
 * cost = 10 - weight
 * </pre>
 *
 * <ul>
 *   <li>Stronger relationships (higher weight) → lower traversal cost</li>
 *   <li>Weaker relationships (weight near 0) → higher cost</li>
 * </ul>
 *
 * <p>The first student encountered who has an internship match becomes
 * the destination, and the algorithm reconstructs the path via predecessors.</p>
 */
public class ReferralPathFinder {

    /** The social/connection graph used to evaluate referral strength. */
    private final StudentGraph graph;

    /**
     * Creates a new path-finder that operates on a given {@link StudentGraph}.
     *
     * @param graph the graph of student relationships
     */
    public ReferralPathFinder(StudentGraph graph) {
        this.graph = graph;
    }

    /**
     * Finds the shortest referral path from a starting student to any student who
     * has previously interned at the specified company using Dijkstra's algorithm.
     *
     * <p>Algorithm steps:</p>
     * <ol>
     *     <li>Identify all students who have {@code targetCompany} in their internship list.</li>
     *     <li>Run Dijkstra from {@code start} using cost = 10 - weight.</li>
     *     <li>Stop early as soon as a target student is dequeued.</li>
     *     <li>Reconstruct the path using predecessor tracking.</li>
     * </ol>
     *
     * @param start the student from whom the referral search begins
     * @param targetCompany the company for which a referral is sought
     * @return a list of {@link UniversityStudent} objects representing the
     *         referral path including both start and target;
     *         returns an empty list if no path exists
     */
    public List<UniversityStudent> findReferralPath(UniversityStudent start, String targetCompany) {
        if (start == null || targetCompany == null || graph == null) {
            return Collections.emptyList();
        }

        // Collect students with matching internship names
        Set<UniversityStudent> targets = new HashSet<>();
        for (UniversityStudent s : graph.getAllNodes()) {
            for (String c : s.getPreviousInternships()) {
                if (c != null && c.equalsIgnoreCase(targetCompany)) {
                    targets.add(s);
                    break;
                }
            }
        }

        if (targets.isEmpty()) return Collections.emptyList();

        // Initialize Dijkstra structures
        Map<UniversityStudent, Double> dist = new HashMap<>();
        Map<UniversityStudent, UniversityStudent> prev = new HashMap<>();

        for (UniversityStudent s : graph.getAllNodes()) {
            dist.put(s, Double.POSITIVE_INFINITY);
        }
        dist.put(start, 0.0);

        PriorityQueue<UniversityStudent> pq =
                new PriorityQueue<>(Comparator.comparingDouble(dist::get));
        pq.add(start);

        // Main Dijkstra loop
        while (!pq.isEmpty()) {
            UniversityStudent u = pq.poll();
            double d = dist.get(u);

            // Early exit: if u is a target, reconstruct the path
            if (targets.contains(u)) {
                return buildPath(prev, u);
            }

            // Relax edges
            for (StudentGraph.Edge e : graph.getNeighbors(u)) {
                double cost = 10.0 - e.weight;
                if (cost < 0) cost = 0;  // clamp to non-negative
                double newDist = d + cost;

                if (newDist < dist.getOrDefault(e.neighbor, Double.POSITIVE_INFINITY)) {
                    dist.put(e.neighbor, newDist);
                    prev.put(e.neighbor, u);

                    // Reinsert to simulate decrease-key
                    pq.add(e.neighbor);
                }
            }
        }

        // No referral path found
        return Collections.emptyList();
    }

    /**
     * Reconstructs a shortest path from the starting node to a given end node
     * using predecessor pointers generated by Dijkstra's algorithm.
     *
     * @param prev a map from each node to its predecessor in the shortest path tree
     * @param end the final node in the path
     * @return a list representing the full path from start to end
     */
    private List<UniversityStudent> buildPath(
            Map<UniversityStudent, UniversityStudent> prev,
            UniversityStudent end) {

        LinkedList<UniversityStudent> path = new LinkedList<>();
        UniversityStudent cur = end;

        while (cur != null) {
            path.addFirst(cur);
            cur = prev.get(cur);
        }

        return path;
    }
}

